
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>GM Voice Studio</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600&display=swap">
  <style>
    /* ===== Arcane / Mystical GM Screen Theme ===== */
    :root {
      --rpg-bg:        #080c18;
      --rpg-panel:     #0d1128;
      --rpg-panel-alt: #0f1530;
      --rpg-text:      #c8d8f0;
      --rpg-muted:     #6888aa;
      --rpg-accent:    #00d4cc;
      --rpg-accent2:   #7b4fff;
      --rpg-border:    #1a4060;
      --rpg-glow:      rgba(0,212,204,0.22);
      --rpg-input-bg:  #060a16;
      --rpg-error-bg:  #1a0820;
      --rpg-error-border: #7b2fff;
      --rpg-error-text: #ff80c0;
      /* legacy aliases so inline styles still work */
      --rpg-text-muted: #6888aa;
      --rpg-accent-light: #33e8e0;
    }

    @keyframes header-pulse {
      0%,100% { text-shadow: 0 0 18px var(--rpg-glow), 0 0 40px rgba(0,212,204,0.12); }
      50%      { text-shadow: 0 0 30px rgba(0,212,204,0.5), 0 0 60px rgba(0,212,204,0.2); }
    }
    @keyframes panel-pulse {
      0%,100% { box-shadow: 0 4px 24px var(--rpg-glow); }
      50%      { box-shadow: 0 4px 40px rgba(0,212,204,0.35); }
    }

    *, *::before, *::after { box-sizing: border-box; }

    body {
      font-family: 'Crimson Text', Georgia, serif;
      margin: 0;
      padding: 0;
      background: radial-gradient(ellipse at 50% 30%, #0d1535 0%, #060810 100%);
      background-attachment: fixed;
      color: var(--rpg-text);
      min-height: 100vh;
    }

    /* Arcane grid overlay on body */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background-image:
        linear-gradient(rgba(0,212,204,0.04) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,212,204,0.04) 1px, transparent 1px);
      background-size: 40px 40px;
      pointer-events: none;
      z-index: 0;
    }

    /* ===== Full-width Header ===== */
    .gm-header {
      position: relative;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      padding: 18px 30px 14px;
      background: linear-gradient(180deg, #0a0f22 0%, #080c18 100%);
      border-bottom: 1px solid var(--rpg-accent);
      box-shadow: 0 4px 30px var(--rpg-glow);
    }
    .gm-rune {
      font-size: 1.6em;
      color: var(--rpg-accent);
      opacity: 0.7;
      animation: header-pulse 4s ease-in-out infinite;
    }
    .gm-header h1 {
      margin: 0;
      font-family: 'Cinzel', serif;
      font-size: 1.9em;
      font-weight: 700;
      color: var(--rpg-accent);
      letter-spacing: 0.1em;
      border: none;
      padding: 0;
      animation: header-pulse 4s ease-in-out infinite;
    }

    /* ===== 3-Column GM Screen Layout ===== */
    #gm-screen {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: row;
      align-items: stretch;
      min-height: calc(100vh - 70px);
    }

    .screen-panel {
      flex: 1;
      min-width: 0;
      overflow-y: auto;
      border-right: 1px solid var(--rpg-border);
      background: var(--rpg-panel);
    }
    .screen-panel:last-child { border-right: none; }

    .panel-chrome {
      position: sticky;
      top: 0;
      z-index: 5;
      padding: 10px 16px;
      font-family: 'Cinzel', serif;
      font-size: 0.85em;
      font-weight: 600;
      letter-spacing: 0.12em;
      color: var(--rpg-accent);
      background: linear-gradient(180deg, #0a1428 0%, rgba(8,12,24,0.92) 100%);
      border-bottom: 1px solid var(--rpg-border);
      text-align: center;
      animation: panel-pulse 5s ease-in-out infinite;
      -webkit-backdrop-filter: blur(4px);
      backdrop-filter: blur(4px);
    }

    /* ===== Containers inside panels ===== */
    .container {
      padding: 18px 16px;
      margin-bottom: 0;
      border-bottom: 1px solid rgba(26,64,96,0.5);
      background: transparent;
    }
    .container:last-child { border-bottom: none; }

    /* ===== Typography ===== */
    h1 {
      font-family: 'Cinzel', serif;
      color: var(--rpg-accent);
      letter-spacing: 0.05em;
      border-bottom: 1px solid var(--rpg-border);
      padding-bottom: 8px;
      margin-top: 0;
    }
    .section-title {
      font-family: 'Cinzel', serif;
      color: var(--rpg-accent);
      margin-top: 18px;
      margin-bottom: 8px;
      font-size: 1.05em;
      padding-left: 10px;
      border-left: 3px solid var(--rpg-accent);
    }

    /* ===== Inputs, Selects, Textareas ===== */
    textarea {
      width: 100%;
      padding: 9px;
      border-radius: 4px;
      border: 1px solid var(--rpg-border);
      background: var(--rpg-input-bg);
      color: var(--rpg-text);
      font-family: inherit;
      margin-bottom: 12px;
      resize: vertical;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    textarea:focus {
      outline: none;
      border-color: var(--rpg-accent);
      box-shadow: 0 0 10px var(--rpg-glow);
    }
    select, input[type="file"] {
      width: 100%;
      padding: 9px;
      margin-top: 4px;
      margin-bottom: 12px;
      background: var(--rpg-input-bg);
      color: var(--rpg-text);
      border: 1px solid var(--rpg-border);
      border-radius: 4px;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    select:focus, input:focus {
      outline: none;
      border-color: var(--rpg-accent);
      box-shadow: 0 0 10px var(--rpg-glow);
    }
    input[type="text"], input[type="password"], input[type="number"] {
      background: var(--rpg-input-bg);
      color: var(--rpg-text);
      border: 1px solid var(--rpg-border);
      border-radius: 4px;
      padding: 9px;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    input[type="text"]:focus, input[type="password"]:focus, input[type="number"]:focus {
      outline: none;
      border-color: var(--rpg-accent);
      box-shadow: 0 0 10px var(--rpg-glow);
    }

    /* Range sliders */
    .slider-group { display: flex; justify-content: space-between; margin-bottom: 12px; gap: 12px; }
    .slider-container { flex: 1; }
    .slider-container input { width: 100%; accent-color: var(--rpg-accent); }

    /* ===== Buttons ===== */
    button {
      width: 100%;
      padding: 12px;
      font-size: 16px;
      font-family: 'Crimson Text', Georgia, serif;
      font-weight: 600;
      background: transparent;
      color: var(--rpg-accent);
      border: 1px solid var(--rpg-accent);
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s, color 0.2s, box-shadow 0.2s;
      letter-spacing: 0.03em;
    }
    button:hover {
      background: var(--rpg-accent);
      color: var(--rpg-bg);
      box-shadow: 0 0 16px var(--rpg-glow);
    }
    button:focus {
      outline: none;
      border-color: var(--rpg-accent);
      box-shadow: 0 0 12px var(--rpg-glow);
    }
    button:disabled {
      background: transparent;
      color: #2a4060;
      border-color: #1a3050;
      cursor: not-allowed;
      box-shadow: none;
    }

    /* ===== Audio / Player ===== */
    .player-container { margin-top: 18px; text-align: center; }
    audio { width: 100%; }

    /* ===== Voice list ===== */
    .voice-list { margin-top: 8px; }
    .voice-item {
      display: flex; align-items: center; gap: 8px; margin-bottom: 6px;
      padding: 7px 8px; background: var(--rpg-input-bg);
      border-radius: 4px; border: 1px solid rgba(0,212,204,0.15);
    }
    .voice-item .label { flex: 1; }
    .voice-item input.edit-name {
      width: 110px; padding: 3px 6px; background: var(--rpg-bg);
      color: var(--rpg-text); border: 1px solid var(--rpg-border); border-radius: 3px;
    }
    .voice-item button { padding: 3px 8px; width: auto; font-size: 12px; }
    .voice-item button.delete { background: #3a0a2a; color: #ff80c0; border-color: #7b2fff; }
    .voice-item button.delete:hover { background: #7b2fff; color: #fff; }
    .voice-item button.set-default { background: transparent; color: var(--rpg-accent); border-color: var(--rpg-accent); }
    .voice-item button.set-default:hover { background: var(--rpg-accent); color: var(--rpg-bg); }
    .default-star { color: var(--rpg-accent); margin-left: 4px; }
    .voice-id-out {
      margin-top: 8px; padding: 9px; background: var(--rpg-bg); border-radius: 4px;
      font-family: monospace; word-break: break-all; color: var(--rpg-muted);
      border: 1px solid var(--rpg-border); font-size: 0.85em;
    }

    /* ===== Consent / misc ===== */
    .consent-box {
      margin: 8px 0; padding: 9px; background: var(--rpg-input-bg);
      border-radius: 4px; border: 1px solid rgba(0,212,204,0.2);
    }
    .narrate-char-over { color: #ff80c0; }

    /* ===== Error area ===== */
    .error-area {
      margin-bottom: 0;
      padding: 12px 20px;
      background: var(--rpg-error-bg);
      border-bottom: 1px solid var(--rpg-error-border);
      color: var(--rpg-error-text);
    }

    /* ===== Co-GM Assistant ===== */
    .npc-roster-bar { display: flex; gap: 7px; flex-wrap: wrap; margin-bottom: 10px; min-height: 30px; align-items: center; }
    .npc-chip {
      padding: 3px 12px; border-radius: 14px; border: 1px solid var(--rpg-accent2);
      background: rgba(123,79,255,0.1); color: var(--rpg-text); cursor: pointer;
      font-family: 'Crimson Text', Georgia, serif; font-size: 0.92em; transition: 0.15s;
    }
    .npc-chip:hover { background: rgba(123,79,255,0.25); border-color: var(--rpg-accent2); }
    .npc-chip.active { background: var(--rpg-accent2); color: #fff; border-color: var(--rpg-accent2); box-shadow: 0 0 10px rgba(123,79,255,0.5); }
    .quick-prompt-bar { display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 10px; }
    .quick-prompt-chip {
      padding: 4px 10px; border-radius: 14px; border: 1px solid var(--rpg-border);
      background: rgba(0,212,204,0.06); color: var(--rpg-muted); cursor: pointer;
      font-size: 0.85em; font-family: 'Crimson Text', Georgia, serif; transition: 0.15s;
    }
    .quick-prompt-chip:hover { background: rgba(0,212,204,0.18); color: var(--rpg-text); border-color: var(--rpg-accent); }
    .dialogue-log {
      background: var(--rpg-input-bg); border: 1px solid var(--rpg-border); border-radius: 4px;
      padding: 10px; min-height: 80px; max-height: 280px; overflow-y: auto;
      margin-bottom: 10px; font-size: 0.93em; color: var(--rpg-text); line-height: 1.5;
    }
    .dialogue-log .log-entry { margin-bottom: 8px; }
    .dialogue-log .log-npc {
      color: var(--rpg-accent); font-style: italic; font-weight: 600;
      background: rgba(0,212,204,0.07); padding: 4px 8px; border-radius: 3px;
      display: block; border-left: 2px solid var(--rpg-accent);
    }
    .dialogue-log .log-gm {
      color: var(--rpg-muted); font-size: 0.86em;
      background: rgba(123,79,255,0.07); padding: 3px 8px; border-radius: 3px;
      display: block; border-left: 2px solid var(--rpg-accent2);
    }
    .cogm-status { font-size: 0.88em; color: var(--rpg-muted); min-height: 1.3em; margin-top: 6px; }
    .btn-small { padding: 5px 12px; font-size: 13px; width: auto; }
    .btn-danger { background: rgba(123,0,60,0.3) !important; color: #ff80c0 !important; border-color: #7b2fff !important; }
    .btn-danger:hover { background: #7b2fff !important; color: #fff !important; }

    /* ===== Scrollbars ===== */
    ::-webkit-scrollbar { width: 5px; height: 5px; }
    ::-webkit-scrollbar-track { background: var(--rpg-bg); }
    ::-webkit-scrollbar-thumb { background: var(--rpg-accent); border-radius: 3px; opacity: 0.7; }

    /* ===== Tab Navigation ===== */
    .gm-tabs {
      position: relative; z-index: 9;
      display: flex; flex-direction: row;
      background: #060a16; border-bottom: 1px solid var(--rpg-border);
    }
    .gm-tab {
      flex: 0 0 auto; width: auto; padding: 10px 32px;
      font-family: 'Cinzel', serif; font-size: 0.88em; font-weight: 600;
      letter-spacing: 0.08em; color: var(--rpg-muted);
      background: transparent; border: none; border-bottom: 2px solid transparent;
      border-radius: 0; cursor: pointer; transition: color 0.2s, border-color 0.2s, box-shadow 0.2s;
    }
    .gm-tab:hover { color: var(--rpg-text); border-bottom-color: var(--rpg-border); box-shadow: none; }
    .gm-tab.active { color: var(--rpg-accent); border-bottom-color: var(--rpg-accent); box-shadow: 0 2px 12px var(--rpg-glow); }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    #tab-session.active { display: flex; flex-direction: column; }

    /* ===== Prep Tab Layout ===== */
    .prep-layout {
      display: grid; grid-template-columns: 1fr 1fr;
      gap: 0; min-height: calc(100vh - 115px);
    }
    .prep-panel { border-right: 1px solid var(--rpg-border); overflow-y: auto; }
    .prep-panel:last-child { border-right: none; }

    /* ===== Adventure Import ===== */
    .import-mode-bar { display: flex; gap: 0; margin-bottom: 14px; border: 1px solid var(--rpg-border); border-radius: 4px; overflow: hidden; }
    .import-mode-btn {
      flex: 1; padding: 8px; font-family: 'Cinzel', serif; font-size: 0.82em;
      background: transparent; color: var(--rpg-muted); border: none; border-radius: 0;
      cursor: pointer; transition: 0.15s; letter-spacing: 0.05em;
    }
    .import-mode-btn:hover { background: rgba(0,212,204,0.08); color: var(--rpg-text); box-shadow: none; }
    .import-mode-btn.active { background: rgba(0,212,204,0.15); color: var(--rpg-accent); border-bottom: 2px solid var(--rpg-accent); }
    .parse-status { font-size: 0.88em; color: var(--rpg-muted); margin: 8px 0; min-height: 1.3em; }
    @keyframes arcane-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    .parse-spinner { display: inline-block; animation: arcane-spin 1.2s linear infinite; margin-right: 6px; }
    .import-results { display: none; margin-top: 16px; }
    .import-results.visible { display: block; }
    .result-section-title {
      font-family: 'Cinzel', serif; font-size: 0.95em; color: var(--rpg-accent);
      margin: 12px 0 8px; padding-left: 8px; border-left: 3px solid var(--rpg-accent);
    }
    .result-cards { display: flex; flex-direction: column; gap: 7px; margin-bottom: 10px; }
    .result-card {
      background: var(--rpg-input-bg); border: 1px solid var(--rpg-border);
      border-radius: 4px; padding: 9px; display: flex; gap: 9px; align-items: flex-start;
      transition: border-color 0.15s;
    }
    .result-card.checked { border-color: var(--rpg-accent); background: rgba(0,212,204,0.05); }
    .result-card input[type="checkbox"] { margin-top: 3px; accent-color: var(--rpg-accent); flex-shrink: 0; width: 15px; height: 15px; cursor: pointer; }
    .result-card-body { flex: 1; min-width: 0; }
    .result-card-title { font-family: 'Cinzel', serif; font-size: 0.88em; color: var(--rpg-text); margin-bottom: 3px; }
    .result-card-detail { font-size: 0.83em; color: var(--rpg-muted); line-height: 1.4; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 3; line-clamp: 3; -webkit-box-orient: vertical; }
    .result-card-badge { font-size: 0.72em; color: var(--rpg-accent2); border: 1px solid var(--rpg-accent2); border-radius: 3px; padding: 1px 5px; margin-left: 5px; vertical-align: middle; }

    /* ===== Responsive: below 1100px stack panels ===== */
    @media (max-width: 1100px) {
      #gm-screen { flex-direction: column; }
      .screen-panel { border-right: none; border-bottom: 1px solid var(--rpg-border); }
      .screen-panel:last-child { border-bottom: none; }
      /* Reorder: center (Co-GM) first, then left, then right */
      .panel-center { order: -1; }
    }

    /* ‚îÄ‚îÄ Utility / override classes (replaces inline styles) ‚îÄ‚îÄ */
    .hidden          { display: none; }
    .mt-4            { margin-top: 4px; }
    .mt-6            { margin-top: 6px; }
    .mt-8            { margin-top: 8px; }
    .mt-10           { margin-top: 10px; }
    .mb-5            { margin-bottom: 5px; }
    .mb-8            { margin-bottom: 8px; }
    .mb-10           { margin-bottom: 10px; }
    .mb-12           { margin-bottom: 12px; }
    .mb-14           { margin-bottom: 14px; }
    .flex-row        { display: flex; }
    .flex-row-8      { display: flex; gap: 8px; }
    .flex-row-10     { display: flex; gap: 10px; }
    .flex-row-sb     { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    .flex-row-wrap   { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .flex-1          { flex: 1; }
    .flex-2          { flex: 2; margin: 0; }
    .input-full      { width: 100%; padding: 9px; }
    .input-full-mb12 { width: 100%; padding: 9px; margin-bottom: 12px; }
    .input-sm        { width: 100%; padding: 8px; margin-top: 4px; }
    .muted-hint      { font-size: 0.88em; color: var(--rpg-muted); margin: 0; }
    .muted-hint-mb10 { font-size: 0.88em; color: var(--rpg-muted); margin: 0 0 10px 0; }
    .muted-hint-mb12 { font-size: 0.88em; color: var(--rpg-muted); margin: 0 0 12px 0; }
    .muted-hint-mb14 { font-size: 0.88em; color: var(--rpg-muted); margin: 0 0 14px 0; }
    .muted-hint-mt4  { font-size: 0.85em; color: var(--rpg-muted); margin: 4px 0 0 0; }
    .muted-hint-mt6  { margin: 4px 0 10px 0; font-size: 0.88em; color: var(--rpg-muted); }
    .muted-span      { font-size: 0.88em; color: var(--rpg-muted); }
    .italic-muted    { color: var(--rpg-muted); font-style: italic; }
    .btn-inline      { width: auto; padding: 3px 10px; font-size: 0.88em; display: inline; vertical-align: baseline; }
    .flex-row-ac-mt14 { margin-top: 14px; display: flex; align-items: center; gap: 10px; }

    /* Elements that start hidden (JS shows/hides via .style.display) */
    #error_area,
    #api_key_wrap,
    #import_text_wrap,
    #import_npcs_section,
    #import_scenes_section { display: none; }

    #narrate_fixed_wrap,
    #record_playback_wrap  { display: none; margin-bottom: 12px; }

    #voice_id_wrap         { display: none; margin-top: 10px; }

    /* Cancel / secondary action buttons (hidden by default) */
    #cancel_tts_btn,
    #cancel_narrate_btn {
      display: none;
      margin-top: 8px;
      padding: 6px 14px;
      font-size: 14px;
      width: auto;
      background: transparent;
      color: var(--rpg-muted);
      border: 1px solid var(--rpg-border);
    }
    #cogm_cancel_btn {
      display: none;
      margin-bottom: 8px;
      background: transparent;
      color: var(--rpg-muted);
      border: 1px solid var(--rpg-border);
    }

    /* Specific form elements */
    #api_key_input         { width: 100%; padding: 9px; margin-bottom: 12px; }
    #set_default_btn       { margin-top: 4px; padding: 6px 12px; font-size: 14px; }
    #export_btn            { margin-top: 8px; padding: 6px 14px; font-size: 13px; width: auto; }
    #cogm_npc_name         { width: 100%; padding: 8px; margin-top: 4px; }
    #cogm_npc_voice        { width: 100%; padding: 8px; margin-top: 4px; }
    #cogm_npc_personality  { margin-top: 4px; }
    #cogm_situation        { margin-top: 4px; margin-bottom: 8px; }
    #cogm_generate_btn     { margin-bottom: 8px; }
    #player-container,
    .player-container      { margin-top: 10px; }
    #saved_scripts_sel     { margin: 0; flex: 2; }
    #load_script_btn       { flex: 1; padding: 9px; }
    #delete_script_btn     { flex: 0.6; padding: 9px; width: auto; }
    #save_script_name      { flex: 2; padding: 9px; margin: 0; }
    #save_script_btn       { flex: 1.2; padding: 9px; }
    #narrate_text          { margin-bottom: 5px; }
    #narrate_char_count_wrap { margin-bottom: 12px; font-size: 0.88em; color: var(--rpg-muted); }
    #narrate_chunk_by      { margin-bottom: 5px; }
    #narrate_max_chars     { width: 100%; padding: 9px; margin-top: 4px; }
    #narrate_status        { margin-top: 8px; color: var(--rpg-muted); font-size: 0.9em; }
    #import_file           { margin-bottom: 12px; }
    #parse_summary         { font-size: 0.88em; color: var(--rpg-muted); }
    #import_selected_btn   { margin-top: 8px; }
    #clone_voice_name,
    #clone_voice_faction   { width: 100%; padding: 9px; margin-bottom: 12px; }
    #record_playback       { display: block; margin-top: 5px; width: 100%; }
    #record_start          { padding: 6px 14px; width: auto; background: rgba(255,80,120,0.2); color: #ff80c0; border: 1px solid #ff80c0; font-weight: bold; }
    #record_stop           { padding: 6px 14px; width: auto; background: transparent; color: var(--rpg-muted); border: 1px solid var(--rpg-border); }
    #record_rerecord       { margin-top: 6px; padding: 5px 10px; width: auto; background: transparent; color: var(--rpg-muted); border: 1px solid var(--rpg-border); }
    #record_status         { font-size: 0.88em; color: var(--rpg-muted); }
    #voice_id_copy_btn     { margin-top: 6px; padding: 5px 12px; font-size: 13px; width: auto; }
    #cogm_clear_log_btn    { font-size: 12px; padding: 3px 10px; }
  </style>
    </head>
    <body>
      <div id="error_area" class="error-area" role="alert"></div>

      <header class="gm-header">
        <span class="gm-rune">·õ≠</span>
        <h1>GM Voice Studio</h1>
        <span class="gm-rune">·õ≠</span>
      </header>

      <nav class="gm-tabs" role="tablist">
        <button type="button" class="gm-tab active" data-tab="session" role="tab" aria-selected="true" aria-controls="tab-session">‚ñ∂ Session</button>
        <button type="button" class="gm-tab" data-tab="prep" role="tab" aria-selected="false" aria-controls="tab-prep">‚öô Prep</button>
      </nav>

      <div class="tab-content active" id="tab-session">
      <div id="gm-screen">

      <!-- ===== LEFT PANEL: Character Voices ===== -->
      <div class="screen-panel panel-left">
        <div class="panel-chrome">‚öî Character Voices ‚öî</div>

        <div id="api_key_wrap" class="container">
          <div class="section-title">API key</div>
          <p class="muted-hint-mb10">This server requires an API key. Enter it below (stored in memory only, not on disk).</p>
          <label for="api_key_input"><strong>API key:</strong></label>
          <input type="password" id="api_key_input" placeholder="Enter your API key" autocomplete="off">
        </div>

        <div class="container">
          <p class="muted-hint-mb10">Clone character and NPC voices, then speak or narrate in-session.</p>

      <div class="section-title">Character / NPC voices</div>
      <div id="voice_list" class="voice-list" role="list"></div>
      <label for="voice_id_sel"><strong>Speak as (character / NPC voice):</strong></label>
      <select id="voice_id_sel" aria-label="Character or NPC voice">
        <option value="">-- Select a character voice (required) --</option>
      </select>
      <button type="button" id="set_default_btn">Set selected as default</button>

      <div class="section-title">Speak a line</div>
      <label for="text"><strong>Dialogue or line:</strong></label>
      <textarea id="text" rows="5" placeholder="Enter dialogue or a short line to speak as the selected character." aria-label="Dialogue or line to speak">The ancient door grinds open, revealing a chamber untouched for centuries.</textarea>
      <label for="tag"><strong>Language:</strong></label>
      <select id="tag" aria-label="Language"></select>
      <p class="muted-hint-mb12">Pocket TTS is English only.</p>
      <label for="ref_audio"><strong>Or one-off clip (this request only):</strong></label>
      <input type="file" id="ref_audio" accept="audio/wav, audio/mp3, audio/ogg" aria-label="One-off reference audio file">

      <div class="section-title">Voice style</div>
      <p class="muted-hint-mb10">For cloned voices, try temperature 0.95‚Äì1.1 if output sounds robotic or pitch feels off.</p>
          <div class="slider-group" role="group" aria-label="Generation parameters">
              <div class="slider-container">
                  <label for="temp">Temperature (<span id="temp_val">0.95</span>)</label><br>
                  <input type="range" id="temp" min="0.1" max="1.5" step="0.05" value="0.95" aria-valuemin="0.1" aria-valuemax="1.5" aria-valuenow="0.95" aria-valuetext="0.95" oninput="var v=this.value; document.getElementById('temp_val').innerText=v; this.setAttribute('aria-valuenow',v); this.setAttribute('aria-valuetext',v);">
                  <p class="muted-hint-mt4">Higher = more varied, expressive; lower = more consistent and stable.</p>
              </div>
              <div class="slider-container">
                  <label for="topp">Top-p (<span id="topp_val">0.9</span>)</label><br>
                  <input type="range" id="topp" min="0.5" max="1.0" step="0.01" value="0.9" aria-valuemin="0.5" aria-valuemax="1" aria-valuenow="0.9" aria-valuetext="0.9" oninput="var v=this.value; document.getElementById('topp_val').innerText=v; this.setAttribute('aria-valuenow',v); this.setAttribute('aria-valuetext',v);">
                  <p class="muted-hint-mt4">Narrower = more focused choices; higher = more diversity in pronunciation.</p>
              </div>
              <div class="slider-container">
                  <label for="rep">Repetition Penalty (<span id="rep_val">1.15</span>)</label><br>
                  <input type="range" id="rep" min="1.0" max="1.5" step="0.01" value="1.15" aria-valuemin="1" aria-valuemax="1.5" aria-valuenow="1.15" aria-valuetext="1.15" oninput="var v=this.value; document.getElementById('rep_val').innerText=v; this.setAttribute('aria-valuenow',v); this.setAttribute('aria-valuetext',v);">
                  <p class="muted-hint-mt4">Higher = discourages repeating the same words or phrases; helps avoid loops.</p>
              </div>
      </div>

      <button id="go" type="button">Generate Audio</button>
          <button type="button" id="cancel_tts_btn">Cancel</button>

          <div class="player-container">
            <audio id="player" controls aria-label="Generated audio playback"></audio>
            <button type="button" id="export_btn" disabled aria-label="Export current audio as WAV">Export WAV</button>
          </div>
        </div><!-- end speak-a-line container -->

        <div class="container">
          <p class="muted-hint">
            To create or import voices and parse adventure modules, switch to the
            <button type="button" onclick="switchTab('prep')" class="btn-inline">‚öô Prep</button>
            tab.
          </p>
        </div>

      </div><!-- end panel-left -->

      <!-- ===== CENTER PANEL: Co-GM Assistant ===== -->
      <div class="screen-panel panel-center">
        <div class="panel-chrome">‚ú¶ Co-GM Assistant ‚ú¶</div>

        <div class="container" id="cogm_panel">
          <p class="muted-hint-mb12">
            Set up an NPC profile, describe what's happening, and Claude writes an in-character line ‚Äî spoken aloud in the NPC's cloned voice.
          </p>

          <div class="section-title">NPC Roster</div>
          <div id="cogm_roster_bar" class="npc-roster-bar" role="list" aria-label="Saved NPCs"></div>
          <div class="flex-row-8 mb-14">
            <button type="button" class="btn-small" id="cogm_save_npc_btn">Save NPC</button>
            <button type="button" class="btn-small btn-danger" id="cogm_delete_npc_btn">Delete NPC</button>
          </div>

          <div class="section-title">NPC Profile</div>
          <div class="flex-row-10 mb-10">
            <div class="flex-1">
              <label for="cogm_npc_name"><strong>Name:</strong></label>
              <input type="text" id="cogm_npc_name" placeholder="e.g. Captain Aldric Vane">
            </div>
            <div class="flex-1">
              <label for="cogm_npc_voice"><strong>Voice:</strong></label>
              <select id="cogm_npc_voice" aria-label="NPC voice">
                <option value="">-- No voice --</option>
              </select>
            </div>
          </div>
          <label for="cogm_npc_personality"><strong>Personality / Notes:</strong></label>
          <textarea id="cogm_npc_personality" rows="3"
                    placeholder="e.g. Gruff veteran, fiercely loyal to the crown, hiding guilt over a past betrayal. Speaks tersely; rarely volunteers information."></textarea>

          <div class="section-title">Current Situation</div>
          <label for="cogm_situation"><strong>What is happening right now?</strong></label>
          <textarea id="cogm_situation" rows="2"
                    placeholder="e.g. Players are demanding to pass the city gate after curfew and have just bribed the guard."></textarea>

          <div class="quick-prompt-bar" id="cogm_quick_prompts" role="group" aria-label="Quick situation prompts">
            <button type="button" class="quick-prompt-chip" data-prompt="The players enter the room and see the NPC for the first time.">Players enter</button>
            <button type="button" class="quick-prompt-chip" data-prompt="The players are threatening the NPC with violence or serious consequences.">Threatened</button>
            <button type="button" class="quick-prompt-chip" data-prompt="The players are offering a bribe of gold or a valuable favor.">Bribed</button>
            <button type="button" class="quick-prompt-chip" data-prompt="The players have gained the NPC's trust and the NPC is about to reveal a closely guarded secret.">Reveal secret</button>
            <button type="button" class="quick-prompt-chip" data-prompt="Combat has just broken out. The NPC reacts to the sudden violence.">Combat begins</button>
            <button type="button" class="quick-prompt-chip" data-prompt="The players are asking the NPC for directions, information, or local knowledge.">Asked for info</button>
          </div>

          <button type="button" id="cogm_generate_btn">Speak as NPC</button>
          <button type="button" id="cogm_cancel_btn" class="btn-small">Cancel</button>
          <div class="cogm-status" id="cogm_status" role="status" aria-live="polite"></div>

          <div class="section-title flex-row-ac-mt14">
            Dialogue Log
            <button type="button" class="btn-small btn-danger" id="cogm_clear_log_btn">Clear</button>
          </div>
          <div id="cogm_dialogue_log" class="dialogue-log" role="log" aria-live="polite" aria-label="NPC dialogue history">
            <span class="italic-muted">No dialogue yet. Configure the NPC above and click Speak as NPC.</span>
          </div>

          <div class="player-container">
            <audio id="cogm_player" controls aria-label="NPC dialogue audio"></audio>
          </div>
        </div><!-- end cogm_panel -->

      </div><!-- end panel-center -->

      <!-- ===== RIGHT PANEL: GM Tools ===== -->
      <div class="screen-panel panel-right">
        <div class="panel-chrome">‚öó GM Tools ‚öó</div>

        <div class="container">
          <div class="section-title">Ambient Audio Mixer</div>
          <p class="muted-hint-mb10">Layer looping atmospheric tracks beneath your NPC dialogue.</p>
          <div class="slider-group">
            <div class="slider-container">
              <label for="vol_rain">City Rain (<span id="vol_rain_val">0</span>%)</label><br>
              <input type="range" id="vol_rain" min="0" max="1" step="0.05" value="0" oninput="document.getElementById('audio_rain').volume=this.value; document.getElementById('vol_rain_val').innerText=Math.round(this.value*100); if(this.value>0) document.getElementById('audio_rain').play(); else document.getElementById('audio_rain').pause();">
              <audio id="audio_rain" loop src="https://cdn.pixabay.com/audio/2021/08/04/audio_3484f3ccab.mp3"></audio>
            </div>
            <div class="slider-container">
              <label for="vol_jazz">Speakeasy Jazz (<span id="vol_jazz_val">0</span>%)</label><br>
              <input type="range" id="vol_jazz" min="0" max="1" step="0.05" value="0" oninput="document.getElementById('audio_jazz').volume=this.value; document.getElementById('vol_jazz_val').innerText=Math.round(this.value*100); if(this.value>0) document.getElementById('audio_jazz').play(); else document.getElementById('audio_jazz').pause();">
              <audio id="audio_jazz" loop src="https://cdn.pixabay.com/audio/2022/01/18/audio_82c206db23.mp3"></audio>
            </div>
            <div class="slider-container">
              <label for="vol_magic">Arcane Hum (<span id="vol_magic_val">0</span>%)</label><br>
              <input type="range" id="vol_magic" min="0" max="1" step="0.05" value="0" oninput="document.getElementById('audio_magic').volume=this.value; document.getElementById('vol_magic_val').innerText=Math.round(this.value*100); if(this.value>0) document.getElementById('audio_magic').play(); else document.getElementById('audio_magic').pause();">
              <audio id="audio_magic" loop src="https://cdn.pixabay.com/audio/2022/03/10/audio_c8c8a73467.mp3"></audio>
            </div>
          </div>
        </div><!-- end ambient mixer -->

        <div class="container">
          <div class="section-title">Scene Script Library</div>
          <p class="muted-hint-mb10">Save and load box-text descriptions for quick narration.</p>
          <div class="flex-row-8 mb-12">
            <select id="saved_scripts_sel" aria-label="Saved scenes">
              <option value="">-- Select a saved scene --</option>
            </select>
            <button type="button" id="load_script_btn">Load</button>
            <button type="button" id="delete_script_btn" class="btn-danger">Delete</button>
          </div>
          <div class="flex-row-8">
            <input type="text" id="save_script_name" placeholder="Scene Name">
            <button type="button" id="save_script_btn">Save Text</button>
          </div>
        </div><!-- end scene scripts -->

        <div class="container">
          <div class="section-title">Narrate scene or script</div>
          <p class="muted-hint">Uses the selected character voice. Paste scene text; it will be split into chunks and combined into one WAV.</p>
          <label for="narrate_text"><strong>Script (max 5000 characters):</strong></label>
          <textarea id="narrate_text" rows="8" placeholder="Paste script or long text..." aria-label="Script for narration"></textarea>
          <div id="narrate_char_count_wrap" role="status" aria-live="polite"><span id="narrate_char_count">0 / 5000 characters</span></div>
          <label for="narrate_chunk_by"><strong>Chunk by:</strong></label>
          <select id="narrate_chunk_by" aria-label="Chunk by">
            <option value="sentence">Sentence</option>
            <option value="paragraph">Paragraph</option>
            <option value="fixed">Fixed (N chars)</option>
          </select>
          <p class="muted-hint-mb12"><strong>Sentence</strong>: split at sentence boundaries. <strong>Paragraph</strong>: split at double line breaks. <strong>Fixed</strong>: split every N characters.</p>
          <div id="narrate_fixed_wrap">
            <label for="narrate_max_chars"><strong>Max characters per chunk:</strong></label>
            <input type="number" id="narrate_max_chars" min="50" max="1500" value="500" aria-label="Max characters per chunk">
          </div>
          <button id="narrate_btn" type="button">Generate narration</button>
          <button type="button" id="cancel_narrate_btn">Cancel</button>
          <div id="narrate_status"></div>
        </div><!-- end narrate -->

      </div><!-- end panel-right -->

      </div><!-- end gm-screen -->
      </div><!-- end tab-session -->

      <!-- ===== PREP TAB ===== -->
      <div class="tab-content" id="tab-prep">
        <div class="prep-layout">

          <!-- LEFT PREP PANEL: Adventure Import -->
          <div class="prep-panel">
            <div class="panel-chrome">üìú Adventure Import</div>
            <div class="container">
              <p class="muted-hint-mb14">
                Upload a PDF, DOCX, or text adventure module. Claude will extract read-aloud passages and NPC profiles, then import them into your Scene Scripts and NPC Roster.
              </p>

              <div class="import-mode-bar" role="group" aria-label="Input mode">
                <button type="button" class="import-mode-btn active" id="import_mode_file_btn" onclick="setImportMode('file')">üìé Upload File</button>
                <button type="button" class="import-mode-btn" id="import_mode_text_btn" onclick="setImportMode('text')">‚úè Paste Text</button>
              </div>

              <div id="import_file_wrap">
                <label for="import_file"><strong>Adventure file (PDF, DOCX, TXT, MD):</strong></label>
                <input type="file" id="import_file" accept=".pdf,.docx,.txt,.md,text/plain,application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document">
              </div>

              <div id="import_text_wrap">
                <label for="import_paste_text"><strong>Paste adventure text:</strong></label>
                <textarea id="import_paste_text" rows="10" placeholder="Paste your adventure module text here..."></textarea>
              </div>

              <button type="button" id="parse_adventure_btn">Parse Adventure</button>
              <div class="parse-status" id="parse_status" role="status" aria-live="polite"></div>

              <!-- Results -->
              <div class="import-results" id="import_results">
                <div class="flex-row-sb">
                  <span id="parse_summary"></span>
                  <div class="flex-row-8">
                    <button type="button" class="btn-small" id="select_all_btn">Select All</button>
                    <button type="button" class="btn-small" id="deselect_all_btn">Deselect All</button>
                  </div>
                </div>

                <div id="import_npcs_section">
                  <div class="result-section-title">‚öî NPCs &amp; Characters</div>
                  <div class="result-cards" id="import_npc_cards"></div>
                </div>

                <div id="import_scenes_section">
                  <div class="result-section-title">üìñ Read-Aloud Passages</div>
                  <div class="result-cards" id="import_scene_cards"></div>
                </div>

                <button type="button" id="import_selected_btn">Import Selected to Session</button>
                <div class="parse-status" id="import_status" role="status" aria-live="polite"></div>
              </div>
            </div><!-- end adventure import container -->
          </div><!-- end left prep panel -->

          <!-- RIGHT PREP PANEL: Create / Manage Voices -->
          <div class="prep-panel">
            <div class="panel-chrome">üéô Voice Management</div>

            <div class="container">
              <div class="section-title">Manage Voices</div>
              <p class="muted-hint-mb10">Rename or delete cloned voices.</p>
              <div id="prep_voice_list" class="voice-list" role="list"></div>
            </div>

            <div class="container">
              <div class="section-title">Create character / NPC voice</div>
              <div class="consent-box">
                <label><input type="checkbox" id="consent" /> I have the right to use this voice. I am the speaker or have their permission. I will not use it to impersonate without disclosure.</label>
              </div>
              <label for="clone_voice_name"><strong>Character or NPC name:</strong></label>
              <input type="text" id="clone_voice_name" placeholder="e.g. Dragon Queen, Guard Captain" aria-label="Character or NPC name">
              <label for="clone_voice_faction"><strong>Faction / Group (Optional):</strong></label>
              <input type="text" id="clone_voice_faction" placeholder="e.g., Silver Court Mages" aria-label="Faction or group">
              <label for="clone_audio"><strong>Upload a clean 5‚Äì30 second audio clip (WAV/MP3, 16 kHz preferred):</strong></label>
              <input type="file" id="clone_audio" accept="audio/wav, audio/mp3, audio/ogg, audio/*" aria-label="Upload audio for cloning">
              <p class="muted-hint-mt6">Or record with your microphone: 15‚Äì25 s in a quiet room, speaking clearly.</p>
              <div class="flex-row-wrap mb-12">
                <button type="button" id="record_start" disabled>Start recording</button>
                <button type="button" id="record_stop" disabled>Stop</button>
                <span id="record_status"></span>
              </div>
              <div id="record_playback_wrap">
                <label class="muted-span">Play recording before cloning:</label>
                <audio id="record_playback" controls></audio>
                <button type="button" id="record_rerecord">Re-record</button>
              </div>
              <label for="consent_scope"><strong>Consent scope:</strong></label>
              <select id="consent_scope" aria-label="Consent scope">
                <option value="tts">TTS only</option>
                <option value="commercial">Commercial use</option>
              </select>
              <p class="muted-hint-mt6">Upload or record a clip above, check consent, then click Create voice.</p>
              <button id="create_voice" type="button" disabled>Create voice</button>
              <div id="voice_id_wrap" role="status" aria-live="polite">
                <div id="voice_id_out" class="voice-id-out"></div>
                <button type="button" id="voice_id_copy_btn" aria-label="Copy voice or job ID">Copy ID</button>
              </div>
            </div><!-- end create voice -->

          </div><!-- end right prep panel -->

        </div><!-- end prep-layout -->
      </div><!-- end tab-prep -->

  <script>
    const DEFAULT_VOICE_KEY = "kani_default_voice_id";
    let voiceListData = [];
    let presetVoices = [];
    let maxNarrateChars = 5000;
    let requireApiKey = false;

    function getAuthHeaders() {
      if (!requireApiKey) return {};
      const key = document.getElementById("api_key_input") && document.getElementById("api_key_input").value.trim();
      if (!key) return {};
      return { "X-API-Key": key };
    }

    async function loadConfig() {
      try {
        const r = await fetch("/config");
        const j = await r.json();
        requireApiKey = !!j.require_api_key;
        const wrap = document.getElementById("api_key_wrap");
        if (wrap) wrap.style.display = requireApiKey ? "block" : "none";
      } catch (e) {}
    }

    async function loadLimits() {
      try {
        const r = await fetch("/limits");
        const j = await r.json();
        if (j.max_narrate_chars) maxNarrateChars = j.max_narrate_chars;
      } catch (e) {}
    }

    function updateNarrateCharCount() {
      const ta = document.getElementById("narrate_text");
      const el = document.getElementById("narrate_char_count");
      const wrap = document.getElementById("narrate_char_count_wrap");
      if (!el || !ta) return;
      const n = ta.value.length;
      el.textContent = n + " / " + maxNarrateChars + " characters";
      if (n > maxNarrateChars) {
        wrap.classList.add("narrate-char-over");
      } else {
        wrap.classList.remove("narrate-char-over");
      }
    }

    async function fetchVoiceList() {
      const r = await fetch("/voices/list", { headers: getAuthHeaders() });
      voiceListData = await r.json();
      return voiceListData;
    }

    function voiceLabel(v) {
      return (v.name && v.name.trim()) ? v.name.trim() : (v.voice_id.slice(0, 8) + "...");
    }

    function refreshVoiceIdSelect() {
      const sel = document.getElementById("voice_id_sel");
      const cur = sel.value;
      sel.innerHTML = '<option value="">-- Select a character voice (required) --</option>';
      presetVoices.forEach(function(name) {
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name.charAt(0).toUpperCase() + name.slice(1) + " (built-in)";
        sel.appendChild(opt);
      });
      if (presetVoices.length && voiceListData.length) {
        const sep = document.createElement("option");
        sep.disabled = true;
        sep.textContent = "‚îÄ‚îÄ Cloned voices ‚îÄ‚îÄ";
        sel.appendChild(sep);
      }
      voiceListData.forEach(function(v) {
        const opt = document.createElement("option");
        opt.value = v.voice_id;
        opt.textContent = voiceLabel(v);
        sel.appendChild(opt);
      });
      const defaultId = localStorage.getItem(DEFAULT_VOICE_KEY);
      if (defaultId && (presetVoices.indexOf(defaultId) !== -1 || voiceListData.some(function(x) { return x.voice_id === defaultId; }))) {
        sel.value = defaultId;
      } else if (cur && (presetVoices.indexOf(cur) !== -1 || voiceListData.some(function(x) { return x.voice_id === cur; }))) {
        sel.value = cur;
      }
    }

    function renderVoiceList() {
      const container = document.getElementById("voice_list");
      container.innerHTML = "";
      voiceListData.forEach(function(v) {
        const row = document.createElement("div");
        row.className = "voice-item";
        const label = document.createElement("span");
        label.className = "label";
        const defaultId = localStorage.getItem(DEFAULT_VOICE_KEY);
        label.textContent = voiceLabel(v) + (defaultId === v.voice_id ? " *" : "");
        const editInput = document.createElement("input");
        editInput.type = "text";
        editInput.className = "edit-name";
        editInput.placeholder = "Name";
        editInput.value = v.name || "";
        editInput.style.display = "none";
        editInput.onblur = function() {
          const name = editInput.value.trim();
          editInput.style.display = "none";
          label.style.display = "";
          if (name !== (v.name || "")) {
            fetch("/voices/" + encodeURIComponent(v.voice_id), {
              method: "PATCH",
              headers: Object.assign({ "Content-Type": "application/json" }, getAuthHeaders()),
              body: JSON.stringify({ name: name })
            }).then(function() { return fetchVoiceList(); }).then(function() {
              refreshVoiceList();
              refreshVoiceIdSelect();
            });
          }
        };
        const editBtn = document.createElement("button");
        editBtn.textContent = "Edit";
        editBtn.onclick = function() {
          label.style.display = "none";
          editInput.style.display = "inline-block";
          editInput.focus();
        };
        const setDefaultBtn = document.createElement("button");
        setDefaultBtn.className = "set-default";
        setDefaultBtn.textContent = "Set default";
        setDefaultBtn.onclick = function() {
          localStorage.setItem(DEFAULT_VOICE_KEY, v.voice_id);
          renderVoiceList();
          refreshVoiceIdSelect();
        };
        const delBtn = document.createElement("button");
        delBtn.className = "delete";
        delBtn.textContent = "Delete";
        delBtn.onclick = function() {
          if (!confirm("Delete this voice?")) return;
          fetch("/voices/" + encodeURIComponent(v.voice_id), { method: "DELETE", headers: getAuthHeaders() })
            .then(function() { return fetchVoiceList(); })
            .then(function() {
              refreshVoiceList();
              refreshVoiceIdSelect();
              if (document.getElementById("voice_id_sel").value === v.voice_id) {
                document.getElementById("voice_id_sel").value = "";
              }
            });
        };
        row.appendChild(label);
        row.appendChild(editInput);
        row.appendChild(editBtn);
        row.appendChild(setDefaultBtn);
        row.appendChild(delBtn);
        container.appendChild(row);
      });
    }

    function refreshVoiceList() {
      renderVoiceList();
    }

    const tagSel = document.getElementById("tag");
    const player = document.getElementById("player");
    const btn = document.getElementById("go");
    const exportBtn = document.getElementById("export_btn");
    let currentExportFilename = null;

    function setExportReady(filename) {
      currentExportFilename = filename || "audio.wav";
      exportBtn.disabled = false;
    }

    function setError(msg) {
      var el = document.getElementById("error_area");
      el.textContent = msg || "";
      el.style.display = msg ? "block" : "none";
    }

    exportBtn.onclick = function() {
      if (!player.src || !currentExportFilename) return;
      const a = document.createElement("a");
      a.href = player.src;
      a.download = currentExportFilename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    };
    const refAudio = document.getElementById("ref_audio");
    const consentCheck = document.getElementById("consent");
    const cloneAudio = document.getElementById("clone_audio");
    const createVoiceBtn = document.getElementById("create_voice");
    const voiceIdWrap = document.getElementById("voice_id_wrap");
    const voiceIdOut = document.getElementById("voice_id_out");
    const voiceIdCopyBtn = document.getElementById("voice_id_copy_btn");

    let recordedBlob = null;
    let recordPlaybackUrl = null;
    let mediaRecorder = null;
    let recordChunks = [];
    let recordStartTime = null;
    let recordTimer = null;

    function setRecordPlayback(blob) {
      const wrap = document.getElementById("record_playback_wrap");
      const audio = document.getElementById("record_playback");
      if (recordPlaybackUrl) {
        URL.revokeObjectURL(recordPlaybackUrl);
        recordPlaybackUrl = null;
      }
      if (blob) {
        recordPlaybackUrl = URL.createObjectURL(blob);
        audio.src = recordPlaybackUrl;
        wrap.style.display = "block";
      } else {
        audio.removeAttribute("src");
        audio.load();
        wrap.style.display = "none";
      }
    }

    function updateCreateVoiceDisabled() {
      const hasInput = cloneAudio.files.length > 0 || recordedBlob;
      createVoiceBtn.disabled = !hasInput;
    }

    function audioBufferToWav(buffer) {
      const numChannels = 1;
      const sampleRate = buffer.sampleRate;
      const channel = buffer.getChannelData(0);
      const len = channel.length;
      const buf = new ArrayBuffer(44 + len * 2);
      const view = new DataView(buf);
      const write = (offset, val) => view.setUint32(offset, val, true);
      const write16 = (offset, val) => view.setInt16(offset, val, true);
      view.setUint8(0, 82); view.setUint8(1, 73); view.setUint8(2, 70); view.setUint8(3, 70);
      write(4, 36 + len * 2);
      view.setUint8(8, 87); view.setUint8(9, 65); view.setUint8(10, 86); view.setUint8(11, 69);
      view.setUint8(12, 102); view.setUint8(13, 109); view.setUint8(14, 116); view.setUint8(15, 32);
      write(16, 16);
      write16(20, 1);
      write16(22, numChannels);
      write(24, sampleRate);
      write(28, sampleRate * 2);
      write16(32, 2);
      write16(34, 16);
      view.setUint8(36, 100); view.setUint8(37, 97); view.setUint8(38, 116); view.setUint8(39, 97);
      write(40, len * 2);
      for (let i = 0; i < len; i++) {
        const s = Math.max(-1, Math.min(1, channel[i]));
        const n = Math.round(s * 32767);
        write16(44 + i * 2, n < 0 ? Math.max(-32768, n) : Math.min(32767, n));
      }
      return new Blob([buf], { type: "audio/wav" });
    }

    consentCheck.onchange = function() {
      document.getElementById("record_start").disabled = !consentCheck.checked;
      updateCreateVoiceDisabled();
    };
    cloneAudio.onchange = function() {
      if (cloneAudio.files.length) {
        recordedBlob = null;
        setRecordPlayback(null);
      }
      updateCreateVoiceDisabled();
    };

    document.getElementById("record_start").onclick = async function() {
      const statusEl = document.getElementById("record_status");
      const startBtn = document.getElementById("record_start");
      const stopBtn = document.getElementById("record_stop");
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const opts = { mimeType: "audio/webm;codecs=opus" };
        if (!MediaRecorder.isTypeSupported(opts.mimeType)) opts.mimeType = "audio/webm";
        mediaRecorder = new MediaRecorder(stream);
        recordChunks = [];
        mediaRecorder.ondataavailable = function(e) { if (e.data.size) recordChunks.push(e.data); };
        mediaRecorder.onstop = async function() {
          stream.getTracks().forEach(function(t) { t.stop(); });
          const blob = new Blob(recordChunks, { type: mediaRecorder.mimeType });
          try {
            const arrayBuffer = await blob.arrayBuffer();
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const decoded = await ctx.decodeAudioData(arrayBuffer);
            const targetSr = 16000;
            const offline = new OfflineAudioContext(1, Math.ceil(decoded.duration * targetSr), targetSr);
            const src = offline.createBufferSource();
            src.buffer = decoded;
            src.connect(offline.destination);
            src.start(0);
            const resampled = await offline.startRendering();
            recordedBlob = audioBufferToWav(resampled);
            setRecordPlayback(recordedBlob);
            const dur = Math.round(decoded.duration);
            let msg = "Recording ready (" + dur + " s, 16 kHz). Play back below, then Create voice to clone.";
            if (dur < 5) msg = "Recording ready (" + dur + " s). Too short ‚Äî use 5‚Äì30 s for best results. " + msg;
            else if (dur > 30) msg = "Recording ready (" + dur + " s). Longer than 30 s ‚Äî server will use first 30 s only. " + msg;
            statusEl.textContent = msg;
            updateCreateVoiceDisabled();
          } catch (e) {
            statusEl.textContent = "Could not process recording: " + (e.message || e);
          }
        };
        mediaRecorder.start();
        recordStartTime = Date.now();
        startBtn.disabled = true;
        stopBtn.disabled = false;
        statusEl.textContent = "Recording... (5‚Äì30 s recommended)";
        recordTimer = setInterval(function() {
          const sec = Math.floor((Date.now() - recordStartTime) / 1000);
          statusEl.textContent = "Recording... " + sec + " s";
        }, 1000);
      } catch (e) {
        statusEl.textContent = "Mic access failed: " + (e.message || e);
      }
    };

    document.getElementById("record_stop").onclick = function() {
      if (mediaRecorder && mediaRecorder.state !== "inactive") {
        mediaRecorder.stop();
        clearInterval(recordTimer);
        document.getElementById("record_start").disabled = false;
        document.getElementById("record_stop").disabled = true;
      }
    };

    document.getElementById("record_rerecord").onclick = function() {
      recordedBlob = null;
      setRecordPlayback(null);
      document.getElementById("record_status").textContent = "";
      updateCreateVoiceDisabled();
    };

    async function loadTags() {
      const r = await fetch("/voices");
      const j = await r.json();
      presetVoices = j.preset_voices || [];
      for (const t of j.language_tags) {
        const opt = document.createElement("option");
        opt.value = t; opt.textContent = t;
        tagSel.appendChild(opt);
      }
    }

        createVoiceBtn.onclick = async () => {
          setError("");
          const hasFile = cloneAudio.files.length > 0;
          if (!hasFile && !recordedBlob) return;
          if (!consentCheck.checked) {
            setError("Please check the consent box above to create a voice.");
            return;
          }
          createVoiceBtn.textContent = "Creating...";
          createVoiceBtn.disabled = true;
      const fd = new FormData();
      if (recordedBlob) {
        fd.append("audio", recordedBlob, "recording.wav");
      } else {
        fd.append("audio", cloneAudio.files[0]);
      }
      fd.append("consent_scope", document.getElementById("consent_scope").value);
      fd.append("name", document.getElementById("clone_voice_name").value || "");
      fd.append("faction", document.getElementById("clone_voice_faction").value || "");
      let cloneResponse = null;
      try {
        const res = await fetch("/voices/clone", { method: "POST", body: fd, headers: getAuthHeaders() });
        if (!res.ok) { const t = await res.text(); throw new Error(t || "Clone failed"); }
        cloneResponse = await res.json();
        voiceIdWrap.style.display = "block";
        recordedBlob = null;
        setRecordPlayback(null);
        document.getElementById("record_status").textContent = "";
        if (cloneResponse.job_id) {
          voiceIdOut.textContent = "Clone queued. Job ID: " + cloneResponse.job_id + ". Checking status...";
          voiceIdWrap.dataset.copyId = cloneResponse.job_id;
          voiceIdCopyBtn.textContent = "Copy job ID";
          voiceIdCopyBtn.style.display = "inline-block";
          const pollJob = async () => {
            try {
              const r = await fetch("/jobs/" + encodeURIComponent(cloneResponse.job_id), { headers: getAuthHeaders() });
              const status = await r.json();
              if (status.status === "completed" && status.voice_id) {
                voiceIdOut.textContent = "Voice created: " + status.voice_id;
                voiceIdWrap.dataset.copyId = status.voice_id;
                voiceIdCopyBtn.textContent = "Copy voice ID";
                await fetchVoiceList();
                refreshVoiceList();
                refreshVoiceIdSelect();
                createVoiceBtn.textContent = "Create voice";
                updateCreateVoiceDisabled();
                setTimeout(function() { voiceIdCopyBtn.focus(); }, 100);
                return;
              }
              if (status.status === "failed") {
                voiceIdOut.textContent = "Clone failed: " + (status.error || "Unknown error");
                voiceIdWrap.dataset.copyId = cloneResponse.job_id;
                createVoiceBtn.textContent = "Create voice";
                updateCreateVoiceDisabled();
                return;
              }
              setTimeout(pollJob, 2000);
            } catch (err) {
              voiceIdOut.textContent = "Error checking status: " + (err.message || err);
              createVoiceBtn.textContent = "Create voice";
              updateCreateVoiceDisabled();
            }
          };
          pollJob();
        } else {
          voiceIdOut.textContent = "Voice created: " + (cloneResponse.voice_id || "");
          voiceIdWrap.dataset.copyId = cloneResponse.voice_id || "";
          voiceIdCopyBtn.textContent = "Copy voice ID";
          voiceIdCopyBtn.style.display = cloneResponse.voice_id ? "inline-block" : "none";
          await fetchVoiceList();
          refreshVoiceList();
          refreshVoiceIdSelect();
          if (cloneResponse.voice_id && voiceIdCopyBtn.style.display !== "none") {
            setTimeout(function() { voiceIdCopyBtn.focus(); }, 100);
          }
        }
          } catch (e) {
            setError(e.message || "Clone failed");
          } finally {
            if (!cloneResponse || !cloneResponse.job_id) {
          createVoiceBtn.textContent = "Create voice";
          updateCreateVoiceDisabled();
        }
      }
    };

    voiceIdCopyBtn.onclick = function() {
      const id = voiceIdWrap.dataset.copyId;
      if (!id) return;
      navigator.clipboard.writeText(id).then(function() {
        const t = voiceIdCopyBtn.textContent;
        voiceIdCopyBtn.textContent = "Copied!";
        setTimeout(function() { voiceIdCopyBtn.textContent = t; }, 1500);
      });
    };

    document.getElementById("set_default_btn").onclick = function() {
      const vid = document.getElementById("voice_id_sel").value;
      if (vid) {
        localStorage.setItem(DEFAULT_VOICE_KEY, vid);
        refreshVoiceList();
      }
    };

    const narrateChunkBy = document.getElementById("narrate_chunk_by");
    const narrateFixedWrap = document.getElementById("narrate_fixed_wrap");
    narrateChunkBy.onchange = function() {
      narrateFixedWrap.style.display = narrateChunkBy.value === "fixed" ? "block" : "none";
    };

    document.getElementById("narrate_text").addEventListener("input", updateNarrateCharCount);

    document.getElementById("narrate_btn").onclick = async function() {
      const narrateBtn = document.getElementById("narrate_btn");
      const narrateStatus = document.getElementById("narrate_status");
      const cancelNarrateBtn = document.getElementById("cancel_narrate_btn");
      setError("");
      const text = document.getElementById("narrate_text").value.trim();
      if (!text) {
        narrateStatus.textContent = "Please enter some text.";
        return;
      }
      if (text.length > maxNarrateChars) {
        narrateStatus.textContent = "Text exceeds " + maxNarrateChars + " characters. Shorten the script.";
        return;
      }
      narrateBtn.disabled = true;
      cancelNarrateBtn.style.display = "inline-block";
      narrateStatus.textContent = "Generating... (this may take a minute)";
      const body = {
        text: text,
        language_tag: tagSel.value || "en",
        voice_id: document.getElementById("voice_id_sel").value || null,
        chunk_by: narrateChunkBy.value,
        max_chars: parseInt(document.getElementById("narrate_max_chars").value, 10) || 500
      };
      const ac = new AbortController();
      cancelNarrateBtn.onclick = function() { ac.abort(); };
      try {
        const res = await fetch("/tts/narrate", {
          method: "POST",
          headers: Object.assign({ "Content-Type": "application/json" }, getAuthHeaders()),
          body: JSON.stringify(body),
          signal: ac.signal
        });
        if (!res.ok) {
          const err = await res.text();
          throw new Error(err || "Narration failed");
        }
        const blob = await res.blob();
        player.src = URL.createObjectURL(blob);
        player.play();
        setExportReady("narration.wav");
        narrateStatus.textContent = "Done. Use the audio player at the top of the page to listen or download.";
        try { player.focus(); } catch (e) {}
      } catch (e) {
        if (e.name === "AbortError") {
          setError("Request cancelled.");
          narrateStatus.textContent = "Cancelled.";
        } else {
          setError(e.message || "Narration failed");
          narrateStatus.textContent = "Error: " + (e.message || e);
        }
      } finally {
        narrateBtn.disabled = false;
        cancelNarrateBtn.style.display = "none";
      }
    };

    btn.onclick = async () => {
      setError("");
      btn.textContent = "Processing... (This may take a minute on CPU)";
      btn.disabled = true;
      var cancelTtsBtn = document.getElementById("cancel_tts_btn");
      cancelTtsBtn.style.display = "inline-block";

      const fd = new FormData();
      fd.append("text", document.getElementById("text").value);
      fd.append("language_tag", tagSel.value || "en");
      fd.append("temperature", document.getElementById("temp").value);
      fd.append("top_p", document.getElementById("topp").value);
      fd.append("repetition_penalty", document.getElementById("rep").value);

      const vid = document.getElementById("voice_id_sel").value;
      if (vid) fd.append("voice_id", vid);
      else if (refAudio.files.length > 0) fd.append("reference_audio", refAudio.files[0]);

      const ac = new AbortController();
      cancelTtsBtn.onclick = function() { ac.abort(); };
      try {
          const res = await fetch("/tts", { method: "POST", body: fd, headers: getAuthHeaders(), signal: ac.signal });
          if (!res.ok) {
            const errText = await res.text();
            throw new Error(errText || "Generation failed");
          }
          const blob = await res.blob();
          player.src = URL.createObjectURL(blob);
          player.play();
          setExportReady("tts.wav");
          try { player.focus(); } catch (e) {}
      } catch (e) {
          if (e.name === "AbortError") {
            setError("Request cancelled.");
          } else {
            setError(e.message || "Generation failed");
          }
      } finally {
          btn.textContent = "Generate Audio";
          btn.disabled = false;
          cancelTtsBtn.style.display = "none";
      }
    };

    // --- Scene Script Library Logic ---
    function loadSavedScripts() {
        const sel = document.getElementById("saved_scripts_sel");
        sel.innerHTML = '<option value="">-- Select a saved scene --</option>';
        const scripts = JSON.parse(localStorage.getItem("gm_scripts") || "{}");
        for (const name in scripts) {
            const opt = document.createElement("option");
            opt.value = name;
            opt.textContent = name;
            sel.appendChild(opt);
        }
    }

    document.getElementById("save_script_btn").onclick = function() {
        const name = document.getElementById("save_script_name").value.trim();
        const text = document.getElementById("narrate_text").value.trim();
        if (!name || !text) { alert("Please enter both a scene name and text in the Narrate box."); return; }
        const scripts = JSON.parse(localStorage.getItem("gm_scripts") || "{}");
        scripts[name] = text;
        localStorage.setItem("gm_scripts", JSON.stringify(scripts));
        document.getElementById("save_script_name").value = "";
        loadSavedScripts();
    };

    document.getElementById("load_script_btn").onclick = function() {
        const name = document.getElementById("saved_scripts_sel").value;
        if (!name) return;
        const scripts = JSON.parse(localStorage.getItem("gm_scripts") || "{}");
        if (scripts[name]) {
            document.getElementById("narrate_text").value = scripts[name];
            updateNarrateCharCount();
        }
    };

    document.getElementById("delete_script_btn").onclick = function() {
        const name = document.getElementById("saved_scripts_sel").value;
        if (!name || !confirm("Delete scene: " + name + "?")) return;
        const scripts = JSON.parse(localStorage.getItem("gm_scripts") || "{}");
        delete scripts[name];
        localStorage.setItem("gm_scripts", JSON.stringify(scripts));
        loadSavedScripts();
    };

    loadSavedScripts();

    // =============================================
    // Co-GM Assistant
    // =============================================

    var COGM_ROSTER_KEY = "gm_npc_roster";
    var cogmHistory = [];       // [{role:"user"|"assistant", content:"..."}]
    var cogmActiveNpcId = null;
    var cogmAbortController = null;

    // --- Roster helpers ---

    function cogmLoadRoster() {
      try { return JSON.parse(localStorage.getItem(COGM_ROSTER_KEY) || "[]"); }
      catch(e) { return []; }
    }

    function cogmSaveRoster(roster) {
      localStorage.setItem(COGM_ROSTER_KEY, JSON.stringify(roster));
    }

    function cogmNpcId(name) {
      return name.trim().toLowerCase().replace(/\s+/g, "_").replace(/[^a-z0-9_]/g, "");
    }

    function cogmRenderRoster() {
      var bar = document.getElementById("cogm_roster_bar");
      bar.innerHTML = "";
      var roster = cogmLoadRoster();
      if (!roster.length) {
        bar.innerHTML = '<span style="color:var(--rpg-text-muted);font-size:0.9em;">No saved NPCs yet ‚Äî fill in a profile and click Save NPC.</span>';
        return;
      }
      roster.forEach(function(npc) {
        var btn = document.createElement("button");
        btn.type = "button";
        btn.className = "npc-chip" + (cogmActiveNpcId === npc.id ? " active" : "");
        btn.textContent = npc.name;
        btn.setAttribute("role", "listitem");
        btn.onclick = function() { cogmLoadNpc(npc); };
        bar.appendChild(btn);
      });
    }

    function cogmLoadNpc(npc) {
      cogmActiveNpcId = npc.id;
      document.getElementById("cogm_npc_name").value = npc.name || "";
      document.getElementById("cogm_npc_personality").value = npc.personality || "";
      var voiceSel = document.getElementById("cogm_npc_voice");
      if (npc.voice_id && voiceSel.querySelector('option[value="' + npc.voice_id + '"]')) {
        voiceSel.value = npc.voice_id;
      }
      cogmHistory = [];
      cogmRenderLog();
      cogmRenderRoster();
      cogmSetStatus("Loaded: " + npc.name);
    }

    document.getElementById("cogm_save_npc_btn").onclick = function() {
      var name = document.getElementById("cogm_npc_name").value.trim();
      if (!name) { cogmSetStatus("Enter an NPC name before saving."); return; }
      var roster = cogmLoadRoster();
      var id = cogmNpcId(name);
      var npc = {
        id: id,
        name: name,
        personality: document.getElementById("cogm_npc_personality").value.trim(),
        voice_id: document.getElementById("cogm_npc_voice").value || "",
      };
      var idx = roster.findIndex(function(n) { return n.id === id; });
      if (idx >= 0) { roster[idx] = npc; } else { roster.push(npc); }
      cogmSaveRoster(roster);
      cogmActiveNpcId = id;
      cogmRenderRoster();
      cogmSetStatus("Saved: " + name);
    };

    document.getElementById("cogm_delete_npc_btn").onclick = function() {
      if (!cogmActiveNpcId) { cogmSetStatus("Select an NPC chip first."); return; }
      var roster = cogmLoadRoster().filter(function(n) { return n.id !== cogmActiveNpcId; });
      cogmSaveRoster(roster);
      cogmActiveNpcId = null;
      cogmRenderRoster();
      cogmSetStatus("NPC deleted.");
    };

    // --- Quick prompt chips ---

    document.querySelectorAll(".quick-prompt-chip").forEach(function(chip) {
      chip.onclick = function() {
        document.getElementById("cogm_situation").value = chip.dataset.prompt;
      };
    });

    // --- Dialogue log ---

    function cogmRenderLog() {
      var log = document.getElementById("cogm_dialogue_log");
      if (!cogmHistory.length) {
        log.innerHTML = '<span style="color:var(--rpg-text-muted);font-style:italic;">No dialogue yet.</span>';
        return;
      }
      var npcName = document.getElementById("cogm_npc_name").value.trim() || "NPC";
      log.innerHTML = cogmHistory.map(function(m) {
        var cls = m.role === "assistant" ? "log-npc" : "log-gm";
        var label = m.role === "assistant" ? npcName : "GM";
        return '<div class="log-entry"><span class="' + cls + '">' + label + ':</span> ' + cogmEscapeHtml(m.content) + '</div>';
      }).join("");
      log.scrollTop = log.scrollHeight;
    }

    function cogmEscapeHtml(s) {
      return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");
    }

    document.getElementById("cogm_clear_log_btn").onclick = function() {
      cogmHistory = [];
      cogmRenderLog();
      cogmSetStatus("Conversation cleared.");
    };

    function cogmSetStatus(msg) {
      document.getElementById("cogm_status").textContent = msg;
    }

    // --- Populate Co-GM voice dropdown (mirrors voice_id_sel) ---

    function cogmRefreshVoiceSelect() {
      var sel = document.getElementById("cogm_npc_voice");
      var cur = sel.value;
      sel.innerHTML = '<option value="">-- No voice --</option>';
      presetVoices.forEach(function(name) {
        var opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name.charAt(0).toUpperCase() + name.slice(1) + " (built-in)";
        sel.appendChild(opt);
      });
      if (presetVoices.length && voiceListData.length) {
        var sep = document.createElement("option");
        sep.disabled = true;
        sep.textContent = "\u2500\u2500 Cloned voices \u2500\u2500";
        sel.appendChild(sep);
      }
      voiceListData.forEach(function(v) {
        var opt = document.createElement("option");
        opt.value = v.voice_id;
        opt.textContent = voiceLabel(v);
        sel.appendChild(opt);
      });
      if (cur && sel.querySelector('option[value="' + cur + '"]')) {
        sel.value = cur;
      }
    }

    // Auto-fill NPC name from voice metadata when voice is selected (only if name is empty)
    document.getElementById("cogm_npc_voice").addEventListener("change", function() {
      var vid = this.value;
      if (!vid) return;
      var meta = voiceListData.find(function(v) { return v.voice_id === vid; });
      if (!meta) return;
      if (!document.getElementById("cogm_npc_name").value.trim() && meta.name) {
        document.getElementById("cogm_npc_name").value = meta.name;
      }
    });

    // --- Main generate action ---

    document.getElementById("cogm_generate_btn").onclick = async function() {
      var npcName = document.getElementById("cogm_npc_name").value.trim();
      var personality = document.getElementById("cogm_npc_personality").value.trim();
      var situation = document.getElementById("cogm_situation").value.trim();
      var voiceId = document.getElementById("cogm_npc_voice").value;

      // Look up faction from loaded voice metadata
      var faction = "";
      if (voiceId) {
        var meta = voiceListData.find(function(v) { return v.voice_id === voiceId; });
        if (meta && meta.faction) faction = meta.faction;
      }

      if (!npcName) { cogmSetStatus("Enter an NPC name."); return; }
      if (!personality) { cogmSetStatus("Add a personality description."); return; }
      if (!situation) { cogmSetStatus("Describe the current situation."); return; }

      var genBtn = document.getElementById("cogm_generate_btn");
      var cancelBtn = document.getElementById("cogm_cancel_btn");
      genBtn.disabled = true;
      cancelBtn.style.display = "inline-block";
      cogmSetStatus("Generating dialogue\u2026");
      cogmAbortController = new AbortController();
      cancelBtn.onclick = function() { if (cogmAbortController) cogmAbortController.abort(); };

      try {
        var res = await fetch("/ai/dialogue", {
          method: "POST",
          headers: Object.assign({"Content-Type": "application/json"}, getAuthHeaders()),
          body: JSON.stringify({
            npc_name: npcName,
            personality: personality,
            situation: situation,
            faction: faction,
            conversation_history: cogmHistory,
            voice_id: voiceId || null,
          }),
          signal: cogmAbortController.signal,
        });

        if (!res.ok) {
          var errText = await res.text();
          throw new Error(errText || "Dialogue generation failed");
        }

        var data = await res.json();
        var dialogue = data.dialogue;

        // Append user trigger and NPC response to history; cap at 20 turns
        cogmHistory.push({role: "user", content: "[Situation: " + situation + "]"});
        cogmHistory.push({role: "assistant", content: dialogue});
        if (cogmHistory.length > 20) cogmHistory = cogmHistory.slice(cogmHistory.length - 20);

        cogmRenderLog();

        if (voiceId) {
          cogmSetStatus("Speaking\u2026");
          await cogmSpeakDialogue(dialogue, voiceId);
        } else {
          cogmSetStatus("Done. (Assign a voice in the NPC Profile to hear it spoken.)");
        }

      } catch(e) {
        if (e.name === "AbortError") {
          cogmSetStatus("Cancelled.");
        } else {
          cogmSetStatus("Error: " + (e.message || e));
          setError(e.message || "Dialogue generation failed");
        }
      } finally {
        genBtn.disabled = false;
        cancelBtn.style.display = "none";
        cogmAbortController = null;
      }
    };

    async function cogmSpeakDialogue(text, voiceId) {
      var fd = new FormData();
      fd.append("text", text);
      fd.append("language_tag", "en");
      fd.append("voice_id", voiceId);
      fd.append("temperature", "0.95");
      fd.append("top_p", "0.9");
      fd.append("repetition_penalty", "1.15");
      try {
        var res = await fetch("/tts", {method:"POST", body:fd, headers:getAuthHeaders()});
        if (!res.ok) { var e = await res.text(); throw new Error(e || "TTS failed"); }
        var blob = await res.blob();
        var player = document.getElementById("cogm_player");
        player.src = URL.createObjectURL(blob);
        await player.play();
        cogmSetStatus("Done.");
      } catch(e) {
        cogmSetStatus("Dialogue generated but TTS failed: " + (e.message || e));
      }
    }

    function cogmInit() {
      cogmRenderRoster();
      cogmRenderLog();
    }

    // End Co-GM Assistant
    // =============================================

    loadConfig();
    loadTags().then(function() {
      return fetchVoiceList();
    }).then(function() {
      refreshVoiceList();
      refreshVoiceIdSelect();
      cogmRefreshVoiceSelect();
      cogmInit();
      prepRefreshVoiceList();
    });
    loadLimits().then(function() {
      updateNarrateCharCount();
    });

    // ===== TAB NAVIGATION =====
    function switchTab(name) {
      document.querySelectorAll('.tab-content').forEach(function(el) {
        el.classList.remove('active');
      });
      document.querySelectorAll('.gm-tab').forEach(function(btn) {
        btn.classList.toggle('active', btn.dataset.tab === name);
        btn.setAttribute('aria-selected', btn.dataset.tab === name ? 'true' : 'false');
      });
      var target = document.getElementById('tab-' + name);
      if (target) target.classList.add('active');
    }
    document.querySelectorAll('.gm-tab[data-tab]').forEach(function(btn) {
      btn.addEventListener('click', function() { switchTab(this.dataset.tab); });
    });

    // ===== PREP TAB: Voice list mirror =====
    function prepRefreshVoiceList() {
      var src = document.getElementById('voice_list');
      var dest = document.getElementById('prep_voice_list');
      if (!src || !dest) return;
      dest.innerHTML = src.innerHTML;
      // Re-attach delete/rename listeners by cloning buttons
      dest.querySelectorAll('button.delete').forEach(function(btn) {
        btn.addEventListener('click', function() {
          var vid = this.closest('.voice-item') && this.closest('.voice-item').dataset.vid;
          if (vid) deleteVoice(vid);
        });
      });
    }

    // Re-sync prep voice list whenever session voice list updates
    var _origRefreshVoiceList = refreshVoiceList;
    refreshVoiceList = function() {
      _origRefreshVoiceList();
      prepRefreshVoiceList();
    };

    // ===== ADVENTURE IMPORT =====
    var _importMode = 'file';

    function setImportMode(mode) {
      _importMode = mode;
      document.getElementById('import_file_wrap').style.display = mode === 'file' ? '' : 'none';
      document.getElementById('import_text_wrap').style.display = mode === 'text' ? '' : 'none';
      document.getElementById('import_mode_file_btn').classList.toggle('active', mode === 'file');
      document.getElementById('import_mode_text_btn').classList.toggle('active', mode === 'text');
    }

    document.getElementById('parse_adventure_btn').addEventListener('click', async function() {
      var statusEl = document.getElementById('parse_status');
      var resultsEl = document.getElementById('import_results');
      resultsEl.classList.remove('visible');
      statusEl.innerHTML = '<span class="parse-spinner">‚ú¶</span> Parsing adventure‚Ä¶';
      this.disabled = true;

      var formData = new FormData();
      if (_importMode === 'file') {
        var fileInput = document.getElementById('import_file');
        if (!fileInput.files.length) {
          statusEl.textContent = 'Please select a file first.';
          this.disabled = false;
          return;
        }
        formData.append('file', fileInput.files[0]);
      } else {
        var pasteText = document.getElementById('import_paste_text').value.trim();
        if (!pasteText) {
          statusEl.textContent = 'Please paste some text first.';
          this.disabled = false;
          return;
        }
        formData.append('text', pasteText);
      }

      try {
        var headers = {};
        if (window._apiKey) headers['X-API-Key'] = window._apiKey;
        var resp = await fetch('/ai/parse-adventure', { method: 'POST', headers: headers, body: formData });
        if (!resp.ok) {
          var err = await resp.json().catch(function() { return {detail: resp.statusText}; });
          statusEl.textContent = 'Error: ' + (err.detail || resp.statusText);
          this.disabled = false;
          return;
        }
        var data = await resp.json();
        statusEl.textContent = '';
        renderParseResults(data);
      } catch (e) {
        statusEl.textContent = 'Request failed: ' + e.message;
      }
      this.disabled = false;
    });

    function renderParseResults(data) {
      var resultsEl = document.getElementById('import_results');
      var npcSection = document.getElementById('import_npcs_section');
      var sceneSection = document.getElementById('import_scenes_section');
      var npcCards = document.getElementById('import_npc_cards');
      var sceneCards = document.getElementById('import_scene_cards');
      var summary = document.getElementById('parse_summary');

      var npcs = data.npcs || [];
      var readAlouds = data.read_alouds || [];
      var charCount = data.char_count || 0;

      summary.textContent = npcs.length + ' NPC' + (npcs.length !== 1 ? 's' : '') +
        ', ' + readAlouds.length + ' read-aloud' + (readAlouds.length !== 1 ? 's' : '') +
        ' found (' + Math.round(charCount / 1000) + 'k chars processed)';

      npcCards.innerHTML = '';
      npcs.forEach(function(npc, i) {
        var card = document.createElement('div');
        card.className = 'result-card checked';
        card.dataset.type = 'npc';
        card.dataset.index = i;
        var badge = npc.faction ? '<span class="result-card-badge">' + cogmEscapeHtml(npc.faction) + '</span>' : '';
        var scene = npc.scene ? ' ¬∑ ' + cogmEscapeHtml(npc.scene) : '';
        card.innerHTML =
          '<input type="checkbox" checked aria-label="Import ' + cogmEscapeHtml(npc.name) + '">' +
          '<div class="result-card-body">' +
          '<div class="result-card-title">' + cogmEscapeHtml(npc.name) + badge + '</div>' +
          '<div class="result-card-detail">' + cogmEscapeHtml(npc.personality) + '<br><em style="color:var(--rpg-accent2);">' + cogmEscapeHtml(npc.description || '') + scene + '</em></div>' +
          '</div>';
        card.querySelector('input').addEventListener('change', function() {
          card.classList.toggle('checked', this.checked);
        });
        npcCards.appendChild(card);
      });
      npcSection.style.display = npcs.length ? '' : 'none';

      sceneCards.innerHTML = '';
      readAlouds.forEach(function(ra, i) {
        var card = document.createElement('div');
        card.className = 'result-card checked';
        card.dataset.type = 'scene';
        card.dataset.index = i;
        var scene = ra.scene ? '<span class="result-card-badge">' + cogmEscapeHtml(ra.scene) + '</span>' : '';
        card.innerHTML =
          '<input type="checkbox" checked aria-label="Import ' + cogmEscapeHtml(ra.title) + '">' +
          '<div class="result-card-body">' +
          '<div class="result-card-title">' + cogmEscapeHtml(ra.title) + scene + '</div>' +
          '<div class="result-card-detail">' + cogmEscapeHtml(ra.text) + '</div>' +
          '</div>';
        card.querySelector('input').addEventListener('change', function() {
          card.classList.toggle('checked', this.checked);
        });
        sceneCards.appendChild(card);
      });
      sceneSection.style.display = readAlouds.length ? '' : 'none';

      // Store data for import
      resultsEl._parseData = data;
      resultsEl.classList.add('visible');
    }

    document.getElementById('select_all_btn').addEventListener('click', function() {
      document.querySelectorAll('#import_results .result-card input[type="checkbox"]').forEach(function(cb) {
        cb.checked = true;
        cb.closest('.result-card').classList.add('checked');
      });
    });
    document.getElementById('deselect_all_btn').addEventListener('click', function() {
      document.querySelectorAll('#import_results .result-card input[type="checkbox"]').forEach(function(cb) {
        cb.checked = false;
        cb.closest('.result-card').classList.remove('checked');
      });
    });

    document.getElementById('import_selected_btn').addEventListener('click', function() {
      var resultsEl = document.getElementById('import_results');
      var data = resultsEl._parseData;
      if (!data) return;

      var npcs = data.npcs || [];
      var readAlouds = data.read_alouds || [];
      var importedNpcs = 0, importedScenes = 0;

      // Import checked NPCs into roster (roster is an array of {id, name, personality, voice_id})
      var roster = cogmLoadRoster();
      document.querySelectorAll('#import_npc_cards .result-card').forEach(function(card) {
        if (!card.querySelector('input').checked) return;
        var idx = parseInt(card.dataset.index);
        var npc = npcs[idx];
        if (!npc) return;
        var id = cogmNpcId(npc.name);
        if (roster.findIndex(function(n) { return n.id === id; }) >= 0) return; // skip duplicates
        var personality = npc.personality || '';
        if (npc.description) personality += ' ' + npc.description;
        if (npc.faction) personality = '[' + npc.faction + '] ' + personality;
        roster.push({ id: id, name: npc.name.trim(), personality: personality.trim(), voice_id: '' });
        importedNpcs++;
      });
      cogmSaveRoster(roster);
      cogmRenderRoster();

      // Import checked read-alouds into scene scripts
      var scripts = JSON.parse(localStorage.getItem('gm_scripts') || '{}');
      document.querySelectorAll('#import_scene_cards .result-card').forEach(function(card) {
        if (!card.querySelector('input').checked) return;
        var idx = parseInt(card.dataset.index);
        var ra = readAlouds[idx];
        if (!ra) return;
        var key = ra.title.trim();
        // Avoid overwriting existing scripts; append suffix if collision
        var finalKey = key;
        var n = 2;
        while (scripts[finalKey]) { finalKey = key + ' (' + n++ + ')'; }
        scripts[finalKey] = ra.text;
        importedScenes++;
      });
      localStorage.setItem('gm_scripts', JSON.stringify(scripts));
      loadSavedScripts();

      var statusEl = document.getElementById('import_status');
      statusEl.textContent = 'Imported ' + importedNpcs + ' NPC' + (importedNpcs !== 1 ? 's' : '') +
        ' and ' + importedScenes + ' scene' + (importedScenes !== 1 ? 's' : '') + '.';

      if (importedNpcs > 0 || importedScenes > 0) {
        setTimeout(function() { switchTab('session'); }, 800);
      }
    });

  </script>
</body>
</html>